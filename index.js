#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const prettier = require('prettier');
const dotenv = require('dotenv');
dotenv.config();
const tokens = require('gpt3-tokenizer').default;
const tokenizer = new tokens({ type: 'gpt3' });
const beautify = require("js-beautify/js").js;
const htmlbeautify = require("js-beautify/js").html;
const cssbeautify = require("js-beautify/js").css;
const minify = require('html-minifier').minify;
const CleanCSS = require('clean-css');
const OpenAI = require("openai");
const Terser = require('terser');

if (!process.env.OPENAI_API_KEY) {
  console.log('please set OPENAI_API_KEY in a .env or env var');
  process.exit();
}

const instarray = [...process.argv];
instarray.shift();
instarray.shift();
const transformationInstruction = instarray.join(' ');
const systemPrompt = `Only answer with complete set of modified files with all of their content, no partial files\nPerform the following modifications: ${transformationInstruction}\nReturn only the modified files in the format: filename.ext\n\`\`\`codetype\nfile contents\`\`\`\nfilename.ext\n\`\`\`codetype\nfile contents\`\`\``;
console.trace()
async function generateJsonData() {
  try {
    const srcDirectory = './'; // Specify the source directory path
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });

    const jsonEntries = {};
    const readSrcDirectory = async (srcDirectory) => {
      const files = fs.readdirSync(srcDirectory);
      await Promise.all(files.map(async filename => {
        const filePath = path.join(srcDirectory, filename);
        if (filePath.startsWith('node_modules') || filePath.startsWith('.')) {
          return; // Skip these files
        }
        if (fs.statSync(filePath).isDirectory()) {
          // If the "filename" is a directory, recursively read this directory
          await readSrcDirectory(filePath);
        } else {
          const fileContent = fs.readFileSync(filePath, 'utf8');
          let result;
          try {
            if (filePath.endsWith('.js') || filePath.endsWith('.jsx')) {
              result = (await Terser.minify(fileContent, {
                mangle: false,
                compress: false,
                output: { comments: 'all' },
              })).code;
            } else if (filePath.endsWith('.json') && filePath !== 'package.json' && filePath !== 'package-lock.json') {
              result = JSON.stringify(eval('(' + fileContent + ')'));
            } else if (filePath.endsWith('.ejs') || filePath.endsWith('.html') || filePath.endsWith('.svelte')) {
              const options = {
                includeAutoGeneratedTags: true,
                removeAttributeQuotes: true,
                removeRedundantAttributes: true,
                removeScriptTypeAttributes: true,
                removeStyleLinkTypeAttributes: true,
                sortClassName: true,
                useShortDoctype: true,
                collapseWhitespace: true,
                minifyJS: true,
              };
              result = minify(fileContent, options);
            } else if (filePath.endsWith('.css')) {
              const minifiedCss = new CleanCSS().minify(fileContent).styles;
              result = cssbeautify(minifiedCss, { indent_size: 2 });
            } else {
              return; // Skip unsupported file types
            }
          } catch (e) {
            console.log(`ERROR ON ${filePath}`, e);
            return;
          }
          jsonEntries[filePath] = result;
        }
      }));
    };

    await readSrcDirectory(srcDirectory);

    const generatedJsonData = Object.keys(jsonEntries)
      .filter(filePath => filePath.endsWith('.js') || filePath.endsWith('.jsx') || filePath.endsWith('.json') || filePath.endsWith('.html') || filePath.endsWith('.css')) // Ensure valid file types only
      .map(a => {
        const content = jsonEntries[a].trim();
        return `${path.basename(a)}.\`\`\`\n${content}\n\`\`\``;
      })
      .join('\n'); // Use simple filenames and newlines

    const message = `${generatedJsonData}`;
    const tokensCount = tokenizer.encode(`${transformationInstruction}${transformationInstruction} in the following application:\n\n${message}`).bpe.length + tokenizer.encode(systemPrompt).bpe.length + 15;
    const messages = [
      { "role": "system", "content": systemPrompt },
      { "role": "user", "content": `${message}+\n\n+${transformationInstruction}` },
    ];

    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages,
      temperature: 0.1,
      max_tokens: 16384,
      top_p: 1.0,
      frequency_penalty: 0.0,
      presence_penalty: 0.0,
    });

    if (response.choices[0].finish_reason === 'length') {
      console.log("BAILING OUT BECAUSE FINISH REASON IS LENGTH, PLEASE USE A BIGGER MODEL");
      return;
    }

    const text = response.choices[0].message.content.trim();
    fs.writeFileSync('transformed.out', text);
    return text;
  } catch (error) {
    console.trace(error);
    console.error('Error:', error);
  }
}

// Function to write files from string response
function writeFilesFromStr(str) {
  const codeBlockRegex = /(^.*(?:\n|$))?```([\s\S]*?)```/g;
  let matches;
  const codeBlocks = [];
  let name;
  // Use exec to find all matches
  while ((matches = codeBlockRegex.exec(str)) !== null) {
      // matches[1] will contain the content of the code block
      name = matches[1].trim()
      codeBlocks.push({name:matches[1].trim(), file:matches[0].trim()});
  }
  codeBlocks.forEach(({name, file}, index) => {
      if (!file.trim()) return;

      const parts = file.split('\n').filter(a => a != '');

      if(name) {
        parts.shift()
        parts.shift()
        parts.pop()
      }
      // If we still don't have a name, weâ€™ll try to get it from the first line of the current file
      const fileContent = parts.join('\n').trim();
      console.log(name, fileContent);
      if (name && fileContent) {
          console.log(name);
          function removeTrailingPeriods(str) {
              return str.replace(/\.+$/, '');
          }
          writeFile(removeTrailingPeriods(name), fileContent);
      }
  });

  function writeFile(filePath, content) {
      const directory = path.dirname(filePath);
      fs.mkdirSync(directory, { recursive: true });
      
      if (path.extname(filePath) === '.js' || path.extname(filePath) === '.jsx') {
          content = beautify(content, { indent_size: 2, space_in_empty_paren: true });
      }
      if (path.extname(filePath) === '.json') {
          content = JSON.stringify(JSON.parse(content), null, 2);
      }
      if (path.extname(filePath) === '.html' || path.extname(filePath) === '.ejs' || path.extname(filePath) === '.svelte') {
          content = htmlbeautify(content, { indent_size: 2, preserve_newlines: true });
      }
      if (path.extname(filePath) === '.css') {
          content = cssbeautify(content, { indent_size: 2 });
      }
      
      fs.writeFileSync(filePath, content, 'utf8');
  }
}

if (instarray[0] === 'rewrite') {
  const text = fs.readFileSync('transformed.out');
  writeFilesFromStr(text.toString());
  
} else {
  generateJsonData().then(text => {
    writeFilesFromStr(text);
  });
}
